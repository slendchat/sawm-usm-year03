Отчет к лабораторной работе 4
=============================

Коллизии и радужные таблицы
---------------------------
- **Коллизии хеш-функций.** Коллизия возникает, когда два разных сообщения дают одинаковый хеш. Устаревшие функции вроде MD5 и SHA‑1 подвержены преднамеренному подбору коллизий из‑за недостаточного размера внутреннего состояния и известных криптоанализов. В контексте паролей коллизии позволяют атакующему подобрать альтернативный пароль с тем же хешем или построить поддельные файлы/сертификаты, что подрывает доверие к системе.
- **Радужные таблицы.** Это заранее вычисленные таблицы «хеш → возможный пароль», чаще всего с цепочками сокращений для экономии памяти. Они позволяют мгновенно обратить хеш, если пароль короткий или из популярного словаря. Таблицы эффективно работают только против хешей без соли; как только к каждому паролю добавляется уникальная соль, радужные таблицы перестают быть применимыми, потому что атакующему пришлось бы строить отдельную таблицу под каждую соль.

Уязвимости при хранении паролей на сервере
------------------------------------------
1. **Хранение в открытом виде.** Утечка БД сразу раскрывает все пароли и их повторное использование на других сервисах.
2. **Использование быстрых/устаревших хешей (MD5/SHA‑1/SHA‑256 без соли).** Эти функции слишком быстрые и устойчивые к коллизиям не являются, поэтому легко брутфорсятся через GPU или радужные таблицы.
3. **Отсутствие соли или использование общей соли.** Идентичные пароли дают одинаковые хеши, что облегчает массовые атаки и разрешает радужные таблицы.
4. **Предсказуемые соли (логин, фиксированный суффикс).** Позволяют заранее подготовить атакующие словари и всё ещё ускоряют взлом.
5. **Отсутствие механизма замедления (work factor).** Если bcrypt/Argon2 не настроены на достаточную сложность, современное железо сможет перебирать хеши слишком быстро.
6. **Сторонние уязвимости вокруг паролей:** слабые требования к сложности, повторное использование токенов восстановления, хранение ответов на секретные вопросы без защиты, утечки в логах. Эти слабости часто становятся входной точкой даже при корректном хешировании.

Практика в приложении `php-app-secure`
---------------------------------------
- В контроллерах авторизации 
```php
$hash = password_hash($pass1, PASSWORD_BCRYPT);
        $stmt = $db->prepare("INSERT INTO users (email,password_hash) VALUES (?,?)");
        try {
            $stmt->execute([$email,$hash]);
        } catch(\PDOException $e) {
            $_SESSION['errors'] = ['User already exists.'];
            header('Location: /register'); exit;
        }
```
-  и панели администратора 
```php
        global $db;
        $hash = password_hash($p1, PASSWORD_BCRYPT);
        try {
            $stmt = $db->prepare("
                INSERT INTO users (email, password_hash, is_admin)
                VALUES (?, ?, 1)
            ");
            $stmt->execute([$email, $hash]);
        } catch (\PDOException $e) {
            $_SESSION['errors'] = ['User already exists.'];
            $_SESSION['old']    = ['email'=>$email];
            header('Location: /admin/users/create'); exit;
        }
```
-   пароли сразу хешируются через `password_hash(..., PASSWORD_BCRYPT)` и проверяются `password_verify`. Алгоритм bcrypt автоматически добавляет случайную соль и допускает настройку `cost`, поэтому служит примером современного подхода.
- Таблица `users` 
```sql
CREATE TABLE IF NOT EXISTS users (
  id INT AUTO_INCREMENT PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  is_admin TINYINT(1) DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
- хранит только колонку `password_hash`, исключая появление открытых паролей. 
- Преимущества захешированного хранения: даже внутри самой системы разработчик видит лишь bcrypt-хеши, а соль и фактор стоимости(длительность подсчета хеша) делают атаки радужными таблицами и массовым брутфорсом практически бессмысленными.
